import { jsxs as a, jsx as e } from "react/jsx-runtime";
import * as i from "react";
import { Item as q, ItemText as H, Root as M, Trigger as P, Value as _, Portal as z, Content as A, Viewport as D } from "./SelectParts.js";
import { useId as G } from "../hooks/useId.js";
import { useIntersection as J } from "../hooks/useIntersection.js";
import { Box as C } from "../Box/Box.js";
import { Typography as K } from "../Typography/Typography.js";
import { Field as Q } from "../Field/Field.js";
import { Flex as U } from "../Flex/Flex.js";
import { FieldLabel as X } from "../Field/FieldLabel.js";
import { FieldHint as Y } from "../Field/FieldHint.js";
import { FieldError as Z } from "../Field/FieldError.js";
const ue = ({ children: s, clearLabel: o = "Clear", customizeContent: l, disabled: d, error: c, hint: R, id: O, label: u, labelAction: B, onChange: h, onClear: f, onReachEnd: m, placeholder: F, required: g, selectButtonTitle: ee, startIcon: T, size: $ = "M", value: p, ...y }) => {
  const [w, I] = i.useState(), [V, k] = i.useState(!1), t = G(O), v = `${t}-hint`, E = `${t}-error`, L = (r) => {
    h ? h(typeof p == "number" ? Number(r) : r) : I(r);
  }, N = (r) => {
    k(r);
  }, j = (r) => {
    f && f(r), h || I("");
  }, S = i.useRef(null), W = () => {
    S.current.focus();
  }, b = i.useRef(null), x = `intersection-${CSS.escape(t)}`;
  J(b, (r) => {
    m && m(r);
  }, {
    selectorToWatch: `#${x}`,
    /**
     * We need to know when the select is open because only then will viewportRef
     * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
     */
    skipWhen: !V
  });
  const n = (typeof p < "u" ? p.toString() : w) ?? "";
  return e(Q, { hint: R, error: c, id: t, required: g, children: a(U, { direction: "column", alignItems: "stretch", gap: 1, children: [e(X, { onClick: W, action: B, children: u }), a(M, { onOpenChange: N, disabled: d, required: g, onValueChange: L, value: n, ...y, children: [e(P, { ref: S, "aria-label": u, "aria-describedby": `${v} ${E}`, id: t, startIcon: T, size: $, hasError: !!c, disabled: d, clearLabel: o, onClear: n && f ? j : void 0, children: e(_, { placeholder: F, textColor: n ? "neutral800" : "neutral600", children: n && l ? l(n) : void 0 }) }), e(z, { children: e(A, { position: "popper", sideOffset: 4, children: a(D, { ref: b, children: [s, e(C, { id: x, width: "100%", height: "1px" })] }) }) })] }), e(Y, {}), e(Z, {})] }) });
}, me = i.forwardRef(({ value: s, startIcon: o, children: l, ...d }, c) => a(q, { ref: c, value: s.toString(), ...d, children: [o && e(C, { as: "span", "aria-hidden": !0, children: o }), e(K, { textColor: "neutral800", children: e(H, { children: l }) })] }));
export {
  ue as SingleSelect,
  me as SingleSelectOption
};
