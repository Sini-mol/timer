import { jsxs as d, jsx as e } from "react/jsx-runtime";
import * as c from "react";
import { Cross as D } from "@strapi/icons";
import J, { css as S } from "styled-components";
import { Item as T, ItemIndicator as F, ItemText as K, Group as N, Root as Q, Trigger as U, Value as Z, Portal as ee, Content as re, Viewport as te } from "./SelectParts.js";
import ne from "../BaseCheckbox/assets/checkmark.svg.js";
import { useId as oe } from "../hooks/useId.js";
import { useIntersection as ie } from "../hooks/useIntersection.js";
import { Tag as le } from "../Tag/Tag.js";
import { Box as x } from "../Box/Box.js";
import { Typography as O } from "../Typography/Typography.js";
import { Field as ae } from "../Field/Field.js";
import { Flex as ce } from "../Flex/Flex.js";
import { FieldLabel as de } from "../Field/FieldLabel.js";
import { FieldHint as se } from "../Field/FieldHint.js";
import { FieldError as he } from "../Field/FieldError.js";
const Fe = ({ children: t, clearLabel: o = "Clear", customizeContent: n, disabled: i, error: l, hint: s, id: h, label: p, labelAction: V, onChange: f, onClear: B, onReachEnd: I, placeholder: L, required: $, selectButtonTitle: ue, startIcon: j, size: E = "M", value: m, withTags: b, ...z }) => {
  const k = c.useRef(null), [C, v] = c.useState(), [A, G] = c.useState(!1), u = oe(h), W = `${u}-hint`, q = `${u}-error`, H = (r) => {
    f ? f(r) : v(r);
  }, P = (r) => () => {
    const R = Array.isArray(m) ? m.filter((g) => g !== r) : (C ?? []).filter((g) => g !== r);
    f ? f(R) : v(R);
  }, X = (r) => {
    G(r);
  }, w = c.useRef(null), Y = () => {
    w.current.focus();
  }, y = `intersection-${CSS.escape(u)}`;
  ie(k, (r) => {
    I && I(r);
  }, {
    selectorToWatch: `#${y}`,
    /**
     * We need to know when the select is open because only then will viewportRef
     * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
     */
    skipWhen: !A
  });
  const a = typeof m < "u" ? m : C, _ = (r) => r && typeof r == "object" && r.value ? e(le, { tabIndex: -1, disabled: i, icon: e(D, {}), onClick: P(r.value), children: r.textValue }, r.value) : null;
  return e(ae, { hint: s, error: l, id: u, required: $, children: d(ce, { direction: "column", alignItems: "stretch", gap: 1, children: [e(de, { onClick: Y, action: V, children: p }), d(Q, { onOpenChange: X, disabled: i, required: $, onValueChange: H, value: a, ...z, multi: !0, children: [e(U, { ref: w, "aria-label": p, "aria-describedby": `${W} ${q}`, id: u, startIcon: j, size: E, hasError: !!l, disabled: i, clearLabel: o, onClear: a?.length ? B : void 0, paddingLeft: b && a?.length ? 1 : 3, children: e(Z, { placeholder: L, textColor: a?.length ? "neutral800" : "neutral600", children: a?.length ? b ? _ : n ? n(a) : void 0 : void 0 }) }), e(ee, { children: e(re, { position: "popper", sideOffset: 4, children: d(te, { ref: k, children: [t, e(x, { id: y, width: "100%", height: "1px" })] }) }) })] }), e(se, {}), e(he, {})] }) });
}, Oe = c.forwardRef(({ value: t, children: o, startIcon: n, ...i }, l) => d(T, { ref: l, value: t.toString(), ...i, children: [n && e(x, { as: "span", "aria-hidden": !0, children: n }), e(F, { children: ({ isSelected: s, isIntermediate: h }) => e(M, { hasRadius: !0, overflow: "hidden", position: "relative", $indeterminate: h, $selected: s, zIndex: 1, height: "18px", width: "18px" }) }), e(O, { textColor: "neutral800", children: e(K, { children: o }) })] })), M = J(x)`
  border: 1px solid
    ${({ theme: t, $selected: o, $indeterminate: n }) => o || n ? t.colors.primary600 : t.colors.neutral300};
  background-color: ${({ theme: t, $selected: o, $indeterminate: n }) => o || n ? t.colors.primary600 : t.colors.neutral0};

  ${({ theme: t, $indeterminate: o }) => o && S`
      &::after {
        content: '';
        display: block;
        position: relative;
        color: white;
        height: 2px;
        width: 10px;
        background-color: ${t.colors.neutral0};
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
      }
    `}

  ${({ $selected: t }) => t && S`
      &::after {
        content: '';
        background: url(${ne}) no-repeat no-repeat center center;
        width: 100%;
        height: 100%;
        position: absolute;
      }
    `}
`, Me = c.forwardRef(({ children: t, label: o, startIcon: n, values: i = [], ...l }, s) => d(N, { ref: s, children: [d(T, { value: i, ...l, children: [n && e(x, { as: "span", "aria-hidden": !0, children: n }), e(F, { children: ({ isSelected: h, isIntermediate: p }) => e(M, { hasRadius: !0, overflow: "hidden", position: "relative", $indeterminate: p, $selected: h, zIndex: 1, height: "18px", width: "18px" }) }), e(O, { textColor: "neutral800", children: o })] }), t] }));
export {
  Fe as MultiSelect,
  Me as MultiSelectGroup,
  Oe as MultiSelectOption
};
