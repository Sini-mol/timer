import { jsx as r, jsxs as a } from "react/jsx-runtime";
import * as s from "react";
import { Cross as oe, CarretDown as te } from "@strapi/icons";
import { Combobox as t } from "@strapi/ui-primitives";
import l from "styled-components";
import { useControllableState as ne } from "../hooks/useControllableState.js";
import { useId as le } from "../hooks/useId.js";
import { useIntersection as ie } from "../hooks/useIntersection.js";
import { inputFocusStyle as ae } from "../themes/utils.js";
import { Loader as se } from "../Loader/Loader.js";
import { Box as C } from "../Box/Box.js";
import { Typography as h } from "../Typography/Typography.js";
import { Field as de } from "../Field/Field.js";
import { Flex as p } from "../Flex/Flex.js";
import { FieldLabel as ce } from "../Field/FieldLabel.js";
import { FieldHint as ue } from "../Field/FieldHint.js";
import { FieldError as he } from "../Field/FieldError.js";
const pe = ({ children: e, clearLabel: n = "clear", creatable: d = !1, createMessage: f = (x) => `Create "${x}"`, defaultTextValue: m, disabled: c = !1, error: g, hasMoreItems: E = !1, hint: z, id: P, label: q, labelAction: D, loading: b = !1, loadingMessage: H = "Loading content...", noOptionsMessage: N = () => "No results found", onChange: I, onClear: $, onCreateOption: v, onInputChange: V, onLoadMore: y, placeholder: W = "Select or enter a value", required: R = !1, startIcon: k, textValue: L, value: U }) => {
  const [x, A] = s.useState(!1), [i, T] = ne({
    prop: L,
    defaultProp: m
  }), [G, F] = s.useState(""), S = s.useRef(null), B = s.useRef(null), J = s.useRef(null), u = le(P), K = (o) => {
    $ && !c && (T(""), F(""), $(o), B.current.focus());
  }, Q = (o) => {
    A(o);
  }, X = (o) => {
    T(o);
  }, Y = (o) => {
    F(o);
  }, Z = (o) => {
    V && V(o);
  }, _ = (o) => {
    I && I(o);
  }, O = `intersection-${CSS.escape(u)}`, M = (o) => {
    y && E && !b && y(o);
  }, j = () => {
    v && i && v(i);
  };
  ie(S, M, {
    selectorToWatch: `#${O}`,
    /**
     * We need to know when the select is open because only then will viewportRef
     * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
     */
    skipWhen: !x
  });
  const ee = `${u}-hint`, re = `${u}-error`;
  return r(de, { hint: z, error: g, id: u, required: R, children: a(p, { direction: "column", alignItems: "stretch", gap: 1, children: [r(ce, { action: D, children: q }), a(t.Root, { autocomplete: d ? "list" : "both", onOpenChange: Q, onTextValueChange: X, textValue: i, allowCustomValue: !0, disabled: c, required: R, value: U, onValueChange: _, filterValue: G, onFilterValueChange: Y, children: [a(me, { $hasError: !!g, children: [a(p, { flex: "1", as: "span", gap: 3, children: [k ? r(C, { as: "span", "aria-hidden": !0, children: k }) : null, r(ge, { placeholder: W, id: u, "aria-invalid": !!g, "aria-labelledby": `${ee} ${re}`, onChange: Z, ref: B })] }), a(p, { as: "span", gap: 3, children: [i && $ ? r(fe, { as: "button", hasRadius: !0, background: "transparent", type: "button", onClick: K, "aria-disabled": c, "aria-label": n, title: n, ref: J, children: r(oe, {}) }) : null, r(be, { children: r(te, {}) })] })] }), r(t.Portal, { children: r($e, { sideOffset: 4, children: a(xe, { ref: S, children: [e, d ? r(t.CreateItem, { onPointerUp: j, onClick: j, asChild: !0, children: r(w, { children: r(h, { children: f(i ?? "") }) }) }) : null, !d && !b ? r(t.NoValueFound, { asChild: !0, children: r(w, { $hasHover: !1, children: r(h, { children: N(i ?? "") }) }) }) : null, b ? r(p, { justifyContent: "center", alignItems: "center", paddingTop: 2, paddingBottom: 2, children: r(se, { small: !0, children: H }) }) : null, r(C, { id: O, width: "100%", height: "1px" })] }) }) })] }), r(ue, {}), r(he, {})] }) });
}, Pe = (e) => r(pe, { ...e, creatable: !0 }), fe = l(C)`
  border: none;

  svg {
    height: ${11 / 16}rem;
    width: ${11 / 16}rem;
  }

  svg path {
    fill: ${({ theme: e }) => e.colors.neutral600};
  }
`, me = l(t.Trigger)`
  position: relative;
  border: 1px solid ${({ theme: e, $hasError: n }) => n ? e.colors.danger600 : e.colors.neutral200};
  padding-right: ${({ theme: e }) => e.spaces[3]};
  padding-left: ${({ theme: e }) => e.spaces[3]};
  border-radius: ${({ theme: e }) => e.borderRadius};
  background: ${({ theme: e }) => e.colors.neutral0};
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: ${({ theme: e }) => e.spaces[4]};

  &[data-disabled] {
    color: ${({ theme: e }) => e.colors.neutral600};
    background: ${({ theme: e }) => e.colors.neutral150};
    cursor: not-allowed;
  }

  /* Required to ensure the below inputFocusStyles are adhered too */
  &:focus-visible {
    outline: none;
  }

  ${({ theme: e, $hasError: n }) => ae()({ theme: e, hasError: n })};
`, ge = l(t.TextInput)`
  width: 100%;
  font-size: ${14 / 16}rem;
  color: ${({ theme: e }) => e.colors.neutral800};
  min-height: ${40 / 16}rem;
  border: none;
  background-color: transparent;

  &:focus-visible {
    outline: none;
  }

  &[aria-disabled='true'] {
    cursor: inherit;
  }
`, be = l(t.Icon)`
  & > svg {
    width: ${6 / 16}rem;

    & > path {
      fill: ${({ theme: e }) => e.colors.neutral600};
    }
  }

  &[aria-disabled='true'] {
    cursor: inherit;
  }
`, $e = l(t.Content)`
  background: ${({ theme: e }) => e.colors.neutral0};
  box-shadow: ${({ theme: e }) => e.shadows.filterShadow};
  border: 1px solid ${({ theme: e }) => e.colors.neutral150};
  border-radius: ${({ theme: e }) => e.borderRadius};
  width: var(--radix-combobox-trigger-width);
  /* This is from the design-system figma file. */
  max-height: 15rem;
  z-index: ${({ theme: e }) => e.zIndices[1]};
`, xe = l(t.Viewport)`
  padding: ${({ theme: e }) => e.spaces[1]};
`, qe = s.forwardRef(({ children: e, value: n, disabled: d, textValue: f, ...m }, c) => r(t.ComboboxItem, { asChild: !0, value: n, disabled: d, textValue: f, children: r(w, { ref: c, ...m, children: r(t.ItemText, { asChild: !0, children: r(h, { children: e }) }) }) })), w = l.div`
  width: 100%;
  border: none;
  text-align: left;
  outline-offset: -3px;
  padding: ${({ theme: e }) => e.spaces[2]} ${({ theme: e }) => e.spaces[4]};
  background-color: ${({ theme: e }) => e.colors.neutral0};
  border-radius: ${({ theme: e }) => e.borderRadius};
  user-select: none;

  &[data-selected] {
    background-color: ${({ theme: e }) => e.colors.primary100};

    ${h} {
      color: ${({ theme: e }) => e.colors.primary600};
      font-weight: bold;
    }
  }

  &:hover,
  &[data-highlighted] {
    outline: none;
    background-color: ${({ theme: e, $hasHover: n = !0 }) => n ? e.colors.primary100 : e.colors.neutral0};
  }

  &[data-highlighted] {
    ${h} {
      color: ${({ theme: e }) => e.colors.primary600};
      font-weight: bold;
    }
  }
`;
export {
  pe as Combobox,
  Pe as CreatableCombobox,
  qe as Option,
  w as OptionBox
};
